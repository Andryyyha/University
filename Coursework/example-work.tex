\documentclass[bachelor, och, diploma, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\DeclareMathOperator*{\argmax}{argmax}

\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Обработка естественного языка с помощью платформы Dialogflow}

% Курс
\course{3}

% Группа
\group{311}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Вязкова Андрея Андреевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,т.\,н.} %должность, степень, звание
\saname{В.\,М.\,Соловьев}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{к.\,ф.-м.\,н., доцент}
\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.07.2016}
\practFinish{14.07.2016}

% Год выполнения отчета
\date{2019}

\maketitle
% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
\abbreviations
\begin{description}
    \item КЛ  "--- компьютерная лингвистика;
    \item ЕЯ "--- естественный язык;
    \item NLP(Natural Language Processing) "--- Обработка естественного языка
\end{description}

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
В настоящее время область распознавания человеческой речи является очень популярной. С активным внедрением машинного обучения компьютеры стали лучше понимать естественный язык. Голосовые ассистенты, чат"=боты являются очень популярными механизмами взаимодействия бизнеса с клиентами. Сегодня можно забронировать билет на самолет или записаться на стрижку, всего лишь сказав <<Окей, Google>>, или написав чат"=боту в любимом мессенджере. В данной курсовой работе будет рассмотрена история развития компьютерной лингвистики, основные виды систем распознавания естественного языка, механизмы взаимодействия и основные принципы построения подобных систем.

\section{Основы компьютерной лингвистики}
\subsection{Основные понятия}

Компьютерная лингвистика (КЛ) "--- междисциплинарная область,
которая возникла на стыке таких наук, как лингвистика, математика, информатика (Computer Science), искусственный интеллект (Artificial Intelligence). В своем развитии она до сих пор вбирает и применяет (при необходимости адаптируя) разработанные в этих науках методы и инструменты

Поскольку в КЛ объектом обработки выступают тексты естественного языка, ее развитие невозможно без базовых знаний в области общей
лингвистики (языкознания). Лингвистика изучает общие законы естественного языка "--- его структуру и функционирование, и включает такие области:
\begin{itemize}
\item \textbf{фонология} "--- изучает звуки речи и правила их соединения при формировании речи;
\item \textbf{морфология} "--- занимается внутренней структурой и внешней формой слов речи, включая части речи и их категории;
\item \textbf{синтаксис} "--- изучает структуру предложений, правила сочетаемости и порядка следования слов в предложении, а также общие его свойства
как единицы языка.
\item \textbf{семантика и прагматика} "--- тесно связанные области: семантика занимается смыслом слов, предложений и других единиц речи, а прагматика — особенностями выражения этого смысла в связи с конкретными
целями общения;
\item \textbf{лексикография} "--- описывает лексикон конкретного ЕЯ — его отдельные слова, их грамматические и семантические свойства, а также методы
создания словарей
\end{itemize}

Наиболее тесно компьютерная лингвистика связана с областью искусственного интеллекта (ИИ), в рамках которой разрабатываются программные модели отдельных интеллектуальных функций. 

Общим для указанных наук является компьютерное моделирование как основной способ и итоговая цель исследований, эвристический характер многих применяемых методов.
Несколько упрощенно задача компьютерной лингвистики может быть
сформулирована как разработка методов и средств построения лингвистических процессоров для различных прикладных задач по автоматической обработке текстов на ЕЯ. Разработка лингвистического процессора для некоторой прикладной задачи предполагает формальное описание
лингвистических свойств обрабатываемого текста (хотя бы самое простое),
которое может рассматриваться как \textbf{модель текста} (или \textbf{модель языка}).

\subsection{Области применения}

Сфер применения компьютерной лингвистики достаточно много, однако следует описать некоторые из них\cite{CL}.

\textbf{Машинный перевод} (\textbf{Machine Translation}) "--- самое раннее
приложение КЛ, вместе с которым возникла и развивалась сама эта область. Первые программы перевода были построены в середине прошлого
века и были основаны на простейшей стратегии пословного перевода. Однако довольно быстро было осознано, что машинный перевод требует гораздо
более полной лингвистической модели.
В настоящее время существует целый спектр компьютерных систем
машинного перевода (разного качества), от больших интернациональных
исследовательских проектов до коммерческих автоматических переводчиков.

\textbf{Информационный поиск} (\textbf{Information Retrieval}) и связанные
с ним задачи индексирования, реферирования, классификации и рубрицирования документов.

Полнотекстовый поиск документов в больших базах текстовых документов предполагает индексирование текстов, требующее их простейшей лингвистической предобработки, и создание специальных индексных
структур. Известны несколько моделей информационного поиска, наиболее известной и применяемой является векторная модель, при которой информационный запрос представляется в виде набора слов, а подходящие
(релевантные) документы определяются на основе похожести запроса и
вектора слов документа. Современные интернет-поисковики реализуют эту
модель, выполняя индексирование текстов по употребляемым в них словам
и используя для выдачи релевантных документов весьма изощренные процедуры ранжирования. Актуальное направление исследований в области
информационного поиска "--- многоязыковой поиск по документам.

Относительно новая задача, связанная с информационным поиском —
\textbf{формирование ответов на вопросы} (\textbf{Question Answering}). Пример возможного вопроса: <<Кто придумал вилку?>>. Задача решается путем
определения типа вопроса, поиском текстов, потенциально содержащих ответ на этот вопрос (при этом обычно применяются поисковые машины), и затем извлечением ответа из выданных текстов.

Ещё одна прикладная задача, которая возникла более 50 лет назад
и развитие которой стимулировало появление сети Интернет, "--- это поддержка диалога на ЕЯ. Ранее эта задача чаще всего решалась в рамках
какой"=либо информационной системы, в частности, для обработки запросов на ЕЯ к специализированной базе данных "--- в этом случае язык запросов достаточно ограничен, что позволяет использовать упрощенные метода анализа вопросов, а ответы строить
по шаблонам. В настоящий момент все более широкое распространение в
Интернете получают чат"=боты, поддерживающие беседу с человеком на
некоторую тему и являющиеся наследниками известной системы ELIZA
(разработанной в области ИИ в 70 гг.).

Активно развивающимся направлением является распознавание и
синтез звучащей речи. Неизбежно возникающие ошибки распознавания
исправляются автоматическими методами на основе словарей и морфологических моделей, также применяется машинное обучение.

\section{Чат"=боты и диалоговые агенты}
В данной главе представлены основные концепции диалоговых систем или диалоговых агентов. Эти программы общаются 
с человеком с посредством текста или голоса и делятся на 2 типа
\begin{itemize}
	\item \textbf{Диалоговые агенты, ориентированные на специализированную задачу} "--- предназначены для конкретной задачи и и настроены на короткие диалоги
	с целью получения данных от пользователя для последующей задачи. К ним относятся виртуальные ассистенты, такие как Google Now (и его продолжение 
	Google Assistant), Amazon Alexa, Siri и.т.д. Их диалоговые агенты способны указать направление движения, управлять средствами умного дома, находить рестораны поблизости, совершать телефонные звонки и отправлять текстовые сообщения. Некоторые компании размещают диалоговых агентов на своих сайтах, чтобы отвечать на вопросы пользователей.
	\item \textbf{Чат"=боты} "--- это системы, предназначенные для имитации неструктурированных разговоров или <<чатов>>, характерных для взаимодействия
	людей друг с другом. Чат"=боты также пытаются пройти различные формы теста Тьюринга.  Стоит заметить, что в СМИ термин <<чат"=бот>> используется для обозначения диалогового агента, что является некорректным.
\end{itemize}

\subsection{Чат"=боты}
Как было сказано ранее "--- чат боты "--- это системы, имитирующие человеческий разговор. Как и в почти любой области NLP разделяются на 2 класса:

\begin{itemize}
	\item Чат"=боты на основе правил
	\item Чат"=боты на основе корпуса текстов
\end{itemize}

\subsubsection{Чат боты на основе правил}

ELIZA\cite{NLP1} "--- одна из самых первых диалоговых чат"=бот систем. Она была создана в 1966 году Джозефом Вейценбаумом и работает по принципу активного слушателя, основной прием которого "--- это перифраз сообщения, сказанного пользователем.

ELIZA работает по правилам преобразования шаблонов, например:

\begin{figure}[!ht]
	\centering
	\includegraphics[width=14cm]{1.png}
	\caption{\label{fig:1}%
		Пример правила}
\end{figure}

В системе ELIZA паттерн <<0>> означает любую последовательность символов (аналог * в регулярных выражениях)
Символ <<3>> ссылается на второй <<0>>. Это преобразует фразу <<You hate me>> в <<What makes you think i hates you>>
Архитектура системы выглядит следующим образом:
\begin{figure}[!ht]
	\centering
	\includegraphics[width=14cm]{2.png}
	\caption{\label{fig:2}%
		Упрощенное изображение архитектуры ELIZA}
\end{figure}

Однако Вейценбаум замечает, что некоторые общие слова (например слово I в английском языке) приводит к более общим ответам. Вместо него слово
<<Everybody>> приводит к гораздо более интересным ответам, поскольку его использование указывает, что человек ссылается на конкретное событие или человека. Поэтому ELIZA предпочитает отвечать шаблонами содержащими подобные слова.

Если никаких ключевых слов в предложении не было найдено ELIZA выбирает нейтральный ответ. 
Также ELIZA запоминает последнее предложение в диалоге. Например, всякий раз когда слово <<my>> является ключевым словом с самым высоким рангом
ELIZA случайно выбирает преобразование из памяти, применяет к предложению и кладет в стек.



\begin{figure}[!ht]
		\centering
	\includegraphics[width=14cm]{3.png}
	\caption{\label{fig:3}%
		Пример правил, содердащихся в памяти в ELIZA}
\end{figure}



Люди стали серьезно воспринимать программу. Вейзенбаум рассказывал историю как его сотрудник попросил его выйти во время разговора с Элизой. Когда Вейзенбаум хотел сохранить диалоги для дальнейшего анализа люди стали беспокоиться о вопросах конфиденциальности, что предполагало, что они имели
весьма приватные разговоры с программой.

ELIZA используется и в наше время. Некоторые чат"=бот системы основаны на модифицированных версиях ELIZA.

\subsection{Чат"=боты на корпусах текстов}

Чат"=боты, основанные на корпусах текстов, вместо использования правил, используют данные из диалогов между людьми или из диалогов человека и машины.
Подобные данные можно собирать из диалогов на чат"=платформах, Твиттера или диалогов в фильмах. Данные источники могут обеспечить большие объемы данных и они походи на естественные разговоры.

Существует два типа чат"=ботов:
\begin{itemize}
	\item основанные на информационном поиске (Information Retrieval)
	\item основанные на машинном обучении (Sequence to Sequence)
\end{itemize}

Также как и чат"=боты на основе правил, чат"=боты на основе корпусов слабо моделируют контекст диалога. Вместо этого они генерируют ответ, основанный на
последнем сказанном пользователем предложении. Таким образом они имеют много общего с вопросно"=ответным системами, которые фокусируются на отдельных ответах, игнорируя контекст.

\subsubsection{Чат"=боты, основанные на информационном поиске}

Принцип, лежащий в основе данных чат"=ботов, заключается в том, чтобы реагировать на некоторое пользовательский ход X, повторением соответствующего хода Y из корпуса текста. Различия между подобными системами заключаются в том, как они выбирают корпус текста, и как они решают какое пользовательский ход выбрать.

Распространенным выбором корпуса, является сбор данных из человеческих разговоров. Это могут быть платформы для ведения микроблогов (Twitter, Weibo). Другой подход заключается в сборе данных из диалога человека и чат"=бота.

Используя корпус текста и предложение пользователя, система может выбрать алгоритм извлечения информации из корпуса. Два самых простых метода:

\begin{enumerate}
	\item Вернуть ответ на наиболее похожий ход: учитывая запрос пользователя $q$ и корпус $C$, найти ход $t$ из $C$, который наиболее похож на $q$, и вернуть следующий ход, т. е. ответ человека на $t$ из $C$.
	\[
			r = response(\argmax_{t \in C}{\frac{q^Tt}{||q||t||}})	
	\]
	Идея состоит в том, чтобы ход, который больше всего напоминает ход пользователя и возвращать ответ человека на этот ход.
	
	\item Вернуть наиболее похожий ход: учитывая запрос $q$ и  корпус $C$, вернуть ход $t$ из $C$, который наиболее похож на $q$.
	\[
	r = \argmax_{t \in C}{\frac{q^Tt}{||q||t||}}
	\]
	Идея состоит в том, чтобы сопоставить пользовательский ход с ходами из корпуса.
\end{enumerate}

Хоть первый вариант и кажется наиболее интуитивным, второй вариант на практике показывает себя лучше.

Данный подход может быть расширен за счет счет дополнительного функционала, например: запоминание слов из предыдущих ходов или получение информации о пользователе.

\subsubsection{Seq2Seq чат"=боты}

Альтернативный вариант использования корпуса для генерации диалога "--- это переходить от хода пользователя, к ходу системы. Обычно это своеобразная <<версия>> ELIZA, основанная на машинном обучении.

Эта идея была впервые разработана с использованием машинного перевода на основе фраз, чтобы перевести обращение пользователя к ответу системы. Однако быстро стало ясно, что задача генерации ответов слишком отличается от машинного перевода. В машинном переводе слова или фразы в исходных и целевых предложениях имеют тенденцию хорошо совмещаться друг с другом, но в разговоре пользовательское высказывание не может делиться словами или фразами с последовательным ответом.

Вместо этой модели были разработаны \textbf{seq2seq} модели
\begin{figure}[!ht]
	\centering
	\includegraphics[width=16cm]{4.png}
	\caption{\label{fig:4}%
		Схема seq2seq модели}
\end{figure}

Требуется ряд модификаций базовой модели seq2seq для ее адаптации к задаче генерации ответов. Например, базовые модели seq2seq имеют тенденцию создавать предсказуемые, но повторяющиеся и, следовательно, скучные ответы, такие как <<Я в порядке>> или <<Я не знаю>>, которые закрывают диалог. Эту проблему можно решить, изменив функцию для обучения модели seq2seq.

Другая проблема архитектуры генерации ответов заключается в ее неспособности моделировать более длинный предшествующий контекст диалога. Это можно сделать, позволив модели увидеть предыдущие ходы, например, используя иерархическую модель, которая накапливает информацию за несколько предыдущих ходов.
Наконец, генераторы ответов фокусируются на генерации единичных ответов, и поэтому не имеют тенденций к тому, чтобы непрерывно генерировать ответы, которые связаны между собой в несколько ходов. Эту проблему можно решить с помощью обучения с подкреплением, а также таких методов, как состязательные сети, чтобы научиться выбирать ответы, которые делают общий разговор более естественным

\subsection{Диалоговые агенты}

Современные диалоговые системы основаны на предметной онтологии, структурированных знаниях, представляющая типы намерений, которые система может извлечь из пользовательских предложений.

Онтология определяет один или несколько кадров (фреймов), каждый из которых представляет собой набор слотов, а слот определяет значения, которые может принимать каждый слот. Эта архитектура была впервые введена в 1977 году в системе для планирования поездок GUS, лежащей в основе большинства современных коммерческих
цифровых помощников. На рисунке \ref{fig:5} показан пример диалога с системой.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=16cm]{5.png}
	\caption{\label{fig:5}%
		Пример диалога с GUS}
\end{figure}

Набор слотов в GUS определяет, что система должна знать, а заполнитель каждого слота ограничен значениями определенного семантического типа. Например, в туристическом домене слот может иметь такие значения как город (следовательно, принимать значения, такие как Сан-Франциско или Гонконг) или дата, название авиакомпании или время:

\begin{figure}[!ht]
	\centering
	\includegraphics[width=5cm]{6.png}
	\caption{\label{fig:6}%
		Пример слотов и их семантических типов}
\end{figure}

Типы в GUS (как и в любом современном диалоговом агенте) могут иметь иерархическую структуру. Например дата может состоять из месяца и дня.

\subsubsection{Структура управления диалогового агента}

Архитектура управления диалоговыми системами на основе кадров разработана вокруг фрейма. Цель состоит в том, чтобы заполнить слоты в фрейме теми заполнителями, которые хочет пользователь, а затем выполнить соответствующее действие (ответить на вопрос или забронировать рейс). Большинство основанных на фреймах диалоговых систем основаны на конечных автоматах, которые специально разработаны для этой задачи проектировщиком диалогов.

Пример простой архитектуры представлен на рисунке  \ref{fig:7}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=15cm]{7.png}
	\caption{\label{fig:7}%
		Пример архитектуры конечного автомата для диалога}
\end{figure}

Состояния конечного автомата соответствуют вопросам к пользователю для заполнения слотов, а дуги соответствуют действиям, которые необходимо предпринять в зависимости от того, что отвечает пользователь. Эта система полностью контролирует разговор с пользователем. Система задает пользователю ряд вопросов, игнорируя (или неверно истолковывая) все, что не является прямым ответом на вопрос, а затем переходит к следующему вопросу.

Такая упрощенная архитектура с конечным состоянием обычно применяется только для простых задач, таких как бронирование авиабилетов.
Для большинства приложений пользователям требуется немного больше гибкости. Например, в ситуации планирования командировки пользователь может произнести предложение, которое заполняет несколько слотов одновременно.

Поэтому архитектура GUS в той или иной форме используется в современных системах. Эти системы задают вопросы пользователю, заполняет любой слот указанный пользователем, даже если пользователь указал несколько слотов. Система пропускает вопросы связанные с этими слотами.

Архитектура имеет правила предназначенные для автоматического заполнения слотов при некоторых словах или словосочетаниях. Например для слота <<Пункт назначения>>  для фрейма бронирования самолета система запоминает значение данного слота и заполняет этим значением слот <<Город остановки>> в фрейме бронирования отеля.

Когда система имеет достаточно данных она выполняет определенное действие, например: бронирование билетов или возврат сообщения пользователю.

\subsubsection{Понимание естественного языка для заполнения слотов}

Цель понимания естественного языка в "--- извлечь из высказывания пользователя три вещи:
\begin{enumerate}
	\item \textbf{Домен}. Бронирует ли пользователь билет на самолет, устанавливает будильник?
	\item \textbf{Определение намерений пользователя}. Какую задачу пытается выполнить пользователь?
	\item \textbf{Заполнение слотов}. Извлечь параметры и заполнить соответствующие слоты.
\end{enumerate}

Задача заполнения слотов и более простые задачи классификации домена и намерений являются частными случаями задачи семантического синтаксического анализа.
Метод, используемый в  системе GUS и все еще довольно распространенный в промышленных приложениях, заключается в использовании рукописных правил, часто являющихся частю правил условного действия, прикрепленных к слотам.

Системы, основанные на правилах, могут быть реализованы даже с грамматиками. Некоторые системы состоят из больших семантических грамматик, разработанных вручную, с тысячами правил. Семантическая грамматика "--- это контекстно свободная грамматика, в которой левая часть правила является выражаемым семантическим объектом (название слота).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=15cm]{8.png}
	\caption{\label{fig:8}%
		Пример правил семантической грамматики}
\end{figure}

Одним из важных вопросов является отрицание. Если пользователь указывает, что он <<не может летать во вторник утром>> или хочет встречаться, простая система часто неправильно извлекает <<утро вторника»>>как цель пользователя, а не как отрицание.

Ошибки распознавания речи также должны быть устранены. Одним из распространенных приемов является использование ранжированного  списка предполагаемых транскрипций, а не только одну кандидатуру транскрипции. Регулярные выражения или синтаксические анализаторы могут быть просто запущены для каждого предложения в списке, и могут использоваться любые шаблоны, извлеченные из любой гипотезы.

Метод извлечения информации, основанный на правилах подход очень распространен в промышленных приложениях. Он обладает высокой точностью, и, если домен достаточно узок и специалисты доступны, он также может обеспечить достаточный охват. С другой стороны, подобные методы могут быть дорогостоящими и медленными в создании, а рукописные правила могут страдать от проблем с отзывом.

Распространенной альтернативой является использование машинного обучения. Предполагая, что имеется обучающий набор, который связывает каждое предложение с правильной семантикой, мы можем обучить классификатор для сопоставления предложений, намерений и областей, а также модель последовательности для сопоставления предложений и заполнителей слотов.

\section{Платформа для создания диалговых интерфейсов Dialogflow}

\textbf{Dialogflow} "--- платформа для создания диалоговых агентов, купленная компанией Google в 2016 году. Диалоговые интерфейсы, созданные с помощью Dialogflow работают на широком спектре устройств, включая: телефоны, носимые устройства, умные"=колонки, машины и т. д.

Платформа поддерживает более 14 языков, в которые входит Русский.

В данной курсовой работе показан пример создания диалогового агента, предназначенного для получения информации о расписании занятий в университете.

Первым шагом является создание агента. Необходимо ввести название агента, используемый язык и часовой пояс.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=15cm]{9.png}
	\caption{\label{fig:9}%
		Стартовое окно создания агента}
\end{figure}

Далее откроется окно Intents. Intent "--- обработчик запроса от пользователя. В нем уже представлены два интента: стандартное приветствие, которое реагирует на приветствие пользователем и интент, определенный на случай невозможности распознавания пользовательского закпроса.

Следующий шаг "--- это создание интента. Необходимо заполнить следующую информацию:
\begin{itemize}
	\item название интента
	\item Контекст "--- сохраняет текущее состояние пользовательского запроса и передает данные от одного интента к другому. Различают два типа контекстов: входящий и исходящий. Входящий контекст позволяет интенту запускаться только тогда, когда этот контекст существует. Исходящий контекст сохраняет в себе данные, которые могут быть переданы другому интенту.
	\item События "--- позволяют запустить интент с помощью невербального сигнала, например нажатия кнопки.
	\item Тренировочные фразы "--- приблизительные фразы, с помощью которых данный интент будет активирован во время диалога. Не обязательно указывать все возможные фразы. Инструменты машинного обучения позволят расширить список фраз похожими фразами.
	\item Параметры "--- сущности, которые будут извлекаться из сообщения. Позволяют интерпретировать сообщение пользователя в набор данных, которые можно обработать. Некоторые параметры могут быть обязательными и если пользователь не объявит их во время диалога, система сама спросит его об этих параметрах. Стандартный вид вопрос можно задать в поле Default Prompt. Также в качестве данных для обработки можно использовать оригинальное значение, предоставленное пользователем. Для этого надо в столбце value выбрать интересующую сущность с пометкой original.
	\item Response "--- сообщение, которое будет возвращено пользователю. Существет два типа сообщений: статический и динамический. Первый возвращает неизменяемый текст, определенный в поле Text Response. Второй вариант позволяет отправить HTTP запрос на сторонний сервер, который вернет текстовый ответ.
	\item Fulfillment "--- здесь можно указать использовать ли заполнение слотов и использование строннего сервера для формирования ответа.
\end{itemize}

В рамках моей практической работы был создан интент на действие пользователя о получении расписания занятий.

После того как интент был создан, необходимо определить список сущностей, которые могут извлекаться из сообщения пользователя. Для этого необходимо перейти во вкладку Entities и создать сущность, указав ее имя и значения для данной сущности. Также для значений можно определить синонимы, который также будут распознаны. Также можно разрешить автоматическое распознавание значений, которые не были явно указаны в сущности.

Если предполагается использовать динамические сообщения для ответа, то необходимо настроить соединение со сторонним сервером. Для этого следует перейти во вкладку Fulfillment на боковой панели и указать в поле  URL ссылку на ваш сервер.  Dialogflow будет отправлять POST запрос на сторонний сервер. Также можно настроить авторизацию, чтобы защитить агента от несанкционированного доступа. Также можно в этой вкладке можно написать код на языке JavaScript выполняющий обработку данных от диалогового агента. Данный код будет выполняться на облачном сервисе Google Cloud. 

Чтобы диалоговый агент общался с пользователем, необходим интерфейс. В качестве этого интерфейса могут выступать различные платформы, например мессенджер или цифровой помощник. Чтобы настроить данное взаимодействие, необходимо перейти во вкладку Integrations. Dialogflow поддерживает множество платформ, таких как:
\begin{itemize}
	\item Google Assistant (в том числе и голосовой помощник)
	\item Facebook Messenger
	\item Amazon Alexa
	\item Viber
	\item Telegram
\end{itemize}

Полный список возможных интеграций представлен на рисунках \ref{fig:10} и \ref{fig:11}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=12cm]{10.png}
	\caption{\label{fig:10}%
		Список платформ, поддерживающих интеграцию с Dialogflow}
\end{figure}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=12cm]{11.png}
	\caption{\label{fig:11}%
		Список платформ, поддерживающих интеграцию с Dialogflow}
\end{figure}

В своей практической работе я использовал Telegram Messenger, поэтому мне необходимо передать Dialogflow токен Telegram"=бота, чтобы заврешить интеграцию.

Даилоговый агент улчшает понимание человеческой речи с каждым сообщением, с помощью технологий машинного обучения. Однако его можно дополнительно обучить с помощью датасетов, собранных из предыдущих диалогов. Для этого необходимо перейти во вкладку Training, нажать кнопку Upload и загрузить текстовый файл. В файле каждая фраза диалога должна быть на одной строке. Также можно обучать бота на основе предыдущих диалогов. Достаточно выбрать диалог и выбрать фразы, которые запустили верный интент.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=12cm]{11.png}
	\caption{\label{fig:12}%
		Список платформ, поддерживающих интеграцию с Dialogflow}
\end{figure}

Так как задача диалогового агента, созданного в практической работе "--- возвращать расписание занятий, то необходимо хранить расписание в конкретном месте. Можно хранить расписание в сущностях диалогового агента, однако это нецелесообразно из за большого количества данных. Решено было использовать NoSQL базу данных MongoDB. Для обработки запросов от диалгового агента был разработан HTTP сервер, написанный на языке Python с использованием фреймворка Flask. 

Функция \verb|get_schedule()| получает JSON файл из запроса, извлекает параметры даты, номера курса, специализации и номера группы, затем передает их функцию \verb|get_data_from_database()|

\begin{Verbatim}[fontsize=\small, numbers=left]
@app.route('/webhook', methods=['GET', 'POST'])
def get_schedule():
data = request.get_json(silent=True, force=True)
course = data['queryResult']['parameters']['course']
spec = data['queryResult']['parameters']['specialization']
date = data['queryResult']['parameters']['date']
group_number = data['queryResult']['parameters']['groupNumber']
response = get_data_from_database(course, spec, date, group_number)
return make_response(jsonify(response))
\end{Verbatim}

Функция \verb|get_data_from_database(course, spec, date, group_number)|, проверяет какая сечас неделя (числитель или знаменатель) с помощью функции \verb|is_num(date)|, выполняет запрос в базу по параметрам \verb|date| и \verb|group_number|. Если в данный день занятий нет, то коллекция документов будет пустой и, следовательно, возвращается соответствующее сообщение. Если база данных вернула коллекцию документов, то происходит вызов функции \verb|form_response(res)|

\begin{Verbatim}[fontsize=\small, numbers=left]
def get_data_from_database(course, spec, date, group_number):
year = date[0:4]
month = date[5:7]
day = date[8:10]
week = datetime.date(int(year), int(month), int(day)).isocalendar()[2]
if is_num(date) is False:
res = 
db.schedule.find({"daysOfWeek": week_day[week], "groupNumber": int(group_number)})
if res.count() == 0:
return {'fulfillmentText': 'Сегодня занятий нет. Можете отдохнуть!'}
else:
return form_response(res)
else:
res = 
db.schedule.find({"daysOfWeek": week_day[week], "groupNumber": int(group_number), 
"num": True})
print(res)
if res.count() == 0:
return {'fulfillmentText': 'В этот день занятий нет. Можете отдохнуть!'}
else:
return form_response(res)
\end{Verbatim}

Функция \verb|form_response(res)| извлекает данные из коллекции JSON документов по ключам, предварительно отсортировав  ее по номеру занятия:
\begin{itemize}
	\item \verb|subjectName| "--- название предмета
	\item \verb|type| "--- тип занятия (лекция, практика)
	\item \verb|teacherName| "--- фамилия и инициалы преподавателя
	\item \verb|classroom| "--- номер аудитории
	\item \verb|subGroup| "--- номер подгруппы, если это практическое занятие
	\item \verb|timePeriod| "--- время начала и время окончания занятия
\end{itemize}

\begin{Verbatim}[fontsize=\small, numbers=left]
def form_response(res):
result = ''
for s in sorted(res, key=lambda i: i["lesson"]):
print(s['subjectName'], full_type[s['type']], sep=', ')
result += s['subjectName'] + ', ' + full_type[s['type']] + '\n'
print(s['teacherName'])
result += s['teacherName'] + '\n'
print(s['classroom'])
result += s['classroom'] + '\n'
if s['subGroup'] != 0:
print(str(s['subGroup']) + 'подгруппа')
result += str(s['subGroup']) + 'подгруппа' + '\n'
print(s['timePeriod'])
result += s['timePeriod'] + '\n'
print('---------')
result += '---------' + '\n'
return {'fulfillmentText': result}
\end{Verbatim}

Функция \verb|is_num(date)|, получает на вход дату, узнает по этой дате номер недели и проверяет его на четность. Если неделя четная, то это знаменатель, иначе числитель.

\begin{Verbatim}[fontsize=\small, numbers=left]
def is_num(date):
year = date[0:4]
month = date[5:7]
day = date[8:10]
week = datetime.date(int(year), int(month), int(day)).isocalendar()[1]
if week % 2 == 1:
return True
else:
return False
\end{Verbatim}

После вышеперечисленных действий, управление передается обратно функции \verb|get_schedule()|, где формируется JSON документ, который будет отправлен диалоговому агенту.

% Раздел "Заключение"
\conclusion
В данной курсовой работе были рассмотрены основные виды диалоговых систем, принципы взаимодействия и основы построения. Также было ознакомление с платформой создания диалоговых агентов Dialogflow, на примере создания простого диалогового агента, его настройки и взаимодействия со сторонним HTTP сервером, написанным на языке программирования Python с использованием фреймфорка Flask и NoSQL базы данных MongoDB.


%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix

\section{Нумеруемые объекты в приложении}
\end{document}
